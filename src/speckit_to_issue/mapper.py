"""Map tasks to GitHub issues."""

from typing import Optional

from .models import Issue, SpecContext, Task

# Standard issue body template
STANDARD_TEMPLATE = """## Task: {task_id}

| Field | Value |
|-------|-------|
| **Spec** | {spec_name} |
| **Phase** | {phase} |
| **Priority** | {priority} |
| **Estimate** | {estimate} |
| **Dependencies** | {dependencies} |
{file_row}
{fr_row}
{nfr_row}

## Acceptance Criteria

{acceptance_criteria}

---
*Generated by [speckit-to-issue](https://github.com/speckit/speckit-to-issue)*
"""

# Copilot-optimized issue body template
COPILOT_TEMPLATE = """## Objective

{title}

{file_section}

## Acceptance Criteria

{acceptance_criteria}

## Context

| Field | Value |
|-------|-------|
| Spec | {spec_name} |
| Phase | {phase} |
| Priority | {priority} |
| Estimate | {estimate} |
| Dependencies | {dependencies} |

## Instructions for Copilot

Implement this task following the acceptance criteria above.
- Follow existing code patterns in the repository
- Add appropriate tests if applicable
- Create a pull request when complete

---
*Generated by [speckit-to-issue](https://github.com/speckit/speckit-to-issue)*
"""

# Copilot template with spec context
COPILOT_TEMPLATE_WITH_CONTEXT = """## Objective

{title}

{file_section}

## Acceptance Criteria

{acceptance_criteria}

---

{spec_context}

---

## Task Context

| Field | Value |
|-------|-------|
| Spec | {spec_name} |
| Phase | {phase} |
| Priority | {priority} |
| Estimate | {estimate} |
| Dependencies | {dependencies} |

## Instructions for Copilot

Implement this task following the acceptance criteria above.
- Follow the architecture and patterns described in the Feature Specification
- Use the data models as defined
- Follow existing code patterns in the repository
- Add appropriate tests if applicable
- Create a pull request when complete

---
*Generated by [speckit-to-issue](https://github.com/speckit/speckit-to-issue)*
"""


def format_acceptance_criteria(criteria: list[str]) -> str:
    """Format acceptance criteria as markdown checkboxes.

    Args:
        criteria: List of criterion strings

    Returns:
        Markdown formatted checklist
    """
    if not criteria:
        return "- [ ] No acceptance criteria defined"

    return "\n".join(f"- [ ] {criterion}" for criterion in criteria)


def build_issue_body(
    task: Task,
    copilot_mode: bool = False,
    spec_context: Optional[SpecContext] = None,
) -> str:
    """Generate issue body markdown from a task.

    Args:
        task: Task object
        copilot_mode: If True, use Copilot-optimized template
        spec_context: Optional spec context to include in body

    Returns:
        Markdown string for issue body
    """
    acceptance_criteria = format_acceptance_criteria(task.acceptance_criteria)

    if copilot_mode:
        file_section = ""
        if task.file_path:
            file_section = f"## Files to Modify\n\n- `{task.file_path}`"

        # Use context template if spec_context provided and not empty
        if spec_context and not spec_context.is_empty():
            return COPILOT_TEMPLATE_WITH_CONTEXT.format(
                title=task.title,
                file_section=file_section,
                acceptance_criteria=acceptance_criteria,
                spec_context=spec_context.to_markdown(),
                spec_name=task.spec_name or "N/A",
                phase=task.phase or "N/A",
                priority=task.priority.value.title(),
                estimate=task.estimate,
                dependencies=task.dependencies,
            )
        else:
            return COPILOT_TEMPLATE.format(
                title=task.title,
                file_section=file_section,
                acceptance_criteria=acceptance_criteria,
                spec_name=task.spec_name or "N/A",
                phase=task.phase or "N/A",
                priority=task.priority.value.title(),
                estimate=task.estimate,
                dependencies=task.dependencies,
            )
    else:
        file_row = f"| **File** | `{task.file_path}` |" if task.file_path else ""
        fr_row = f"| **FR** | {task.fr_refs} |" if task.fr_refs else ""
        nfr_row = f"| **NFR** | {task.nfr_refs} |" if task.nfr_refs else ""

        return STANDARD_TEMPLATE.format(
            task_id=task.id,
            spec_name=task.spec_name or "N/A",
            phase=task.phase or "N/A",
            priority=task.priority.value.title(),
            estimate=task.estimate,
            dependencies=task.dependencies,
            file_row=file_row,
            fr_row=fr_row,
            nfr_row=nfr_row,
            acceptance_criteria=acceptance_criteria,
        )


def get_labels_for_task(task: Task) -> list[str]:
    """Generate labels for a task.

    Args:
        task: Task object

    Returns:
        List of label names
    """
    labels = ["task", "speckit", task.priority_label]

    if task.phase_label:
        labels.append(task.phase_label)

    if task.spec_name:
        labels.append(task.spec_label)

    return labels


def task_to_issue(
    task: Task,
    copilot_mode: bool = False,
    spec_context: Optional[SpecContext] = None,
) -> Issue:
    """Convert a Task to an Issue.

    Args:
        task: Task object to convert
        copilot_mode: If True, use Copilot-optimized body
        spec_context: Optional spec context to include

    Returns:
        Issue object ready for creation
    """
    return Issue(
        title=task.full_title,
        body=build_issue_body(task, copilot_mode, spec_context),
        labels=get_labels_for_task(task),
    )
